-- Script generated by Redgate Compare v1.45.1.1821
SET check_function_bodies = false;

-- R__create_required_roles.sql
-- Crea todos los roles requeridos por el baseline si no existen

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ibm') THEN
    CREATE ROLE ibm;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'admin') THEN
    CREATE ROLE admin;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'repl') THEN
    CREATE ROLE repl;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ibm-rewind') THEN
    CREATE ROLE "ibm-rewind";
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ibm-replication') THEN
    CREATE ROLE "ibm-replication";
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'ibm-cloud-base-user-ro') THEN
    CREATE ROLE "ibm-cloud-base-user-ro";
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pg_monitor') THEN
    CREATE ROLE pg_monitor;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'pg_signal_backend') THEN
    CREATE ROLE pg_signal_backend;
  END IF;
END $$;

DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.update_to_postgis_31()...';END$$;
CREATE FUNCTION public.update_to_postgis_31()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
            postgis_31_ver text;
        BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname='postgis') THEN
                    RAISE EXCEPTION 'PostGIS is not installed.';
                END IF;
                SELECT
                    version
                INTO
                    postgis_31_ver
                FROM
                    pg_available_extension_versions
                WHERE
                    name='postgis' AND
                    version like '3.1%' AND
                    version NOT LIKE '%next';
                EXECUTE 'ALTER EXTENSION postgis UPDATE to '|| quote_literal(postgis_31_ver);
                EXECUTE 'SELECT postgis_extensions_upgrade();';
                EXECUTE 'DROP EXTENSION postgis_raster;';
              --  RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.update_to_postgis_31() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.update_to_postgis_31() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.update_to_postgis_25()...';END$$;
CREATE FUNCTION public.update_to_postgis_25()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
            postgis_25_ver text;
        BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname='postgis') THEN
                    RAISE EXCEPTION 'PostGIS is not installed.';
                END IF;
                SELECT
                    version
                INTO
                    postgis_25_ver
                FROM
                    pg_available_extension_versions
                WHERE
                    name='postgis' AND
                    version like '2.5%' AND
                    version NOT LIKE '%next';
                EXECUTE 'ALTER EXTENSION postgis UPDATE to '|| quote_literal(postgis_25_ver);
              --  RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.update_to_postgis_25() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.update_to_postgis_25() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.subscription_slot_none(text, text)...';END$$;
CREATE FUNCTION public.subscription_slot_none(IN subscription_name text, IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %I SET (slot_name = NONE)', subscription_name));
                    PERFORM dblink_disconnect();

                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.subscription_slot_none(IN subscription_name text, IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.subscription_slot_none(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.set_pgaudit_user_logging(text, text[])...';END$$;
CREATE FUNCTION public.set_pgaudit_user_logging(IN username text, IN events text[])
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
                persist_dblink_extension boolean;
                allowed_events TEXT [];
                input_valid boolean;
                pgaudit_ver_check boolean;
        BEGIN
            allowed_events := '{read,write,function,role,ddl,misc,misc_set,none}';
             --lower case the input for case insensitive comparison.
            SELECT array_agg(x.events) INTO events FROM (SELECT btrim(lower(unnest(events)))::TEXT AS events) AS x;
            SELECT events  <@ allowed_events INTO input_valid;
            IF not input_valid
            THEN
                RAISE EXCEPTION 'Invalid options provided: %, Allowed events: %.', events,allowed_events;
            END IF;
            persist_dblink_extension := create_dblink_extension();
            PERFORM dblink_connect(format('dbname=postgres'));
            PERFORM dblink_exec(format('ALTER USER %I SET pgaudit.log TO %L;', username, array_to_string(events, ',')));
            PERFORM dblink_disconnect();
            PERFORM pg_reload_conf();
            IF persist_dblink_extension = FALSE
            THEN
                DROP EXTENSION IF EXISTS dblink;
            END IF;
            RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.set_pgaudit_user_logging(IN username text, IN events text[]) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.set_pgaudit_session_logging(text[])...';END$$;
CREATE FUNCTION public.set_pgaudit_session_logging(IN events text[])
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
                persist_dblink_extension boolean;
                allowed_events TEXT [];
                input_valid boolean;
                pgaudit_ver_check boolean;
        BEGIN
             allowed_events := '{read,write,function,role,ddl,misc,misc_set,none}';
             --lower case the input for case insensitive comparison.
            SELECT array_agg(x.events) INTO events FROM (SELECT btrim(lower(unnest(events)))::TEXT AS events) AS x;
            SELECT events  <@ allowed_events INTO input_valid;
            IF not input_valid
            THEN
                RAISE EXCEPTION 'Invalid options provided: %, Allowed events: %.', events,allowed_events;
            END IF;
            persist_dblink_extension := create_dblink_extension();
            PERFORM dblink_connect(format('dbname=postgres'));
            PERFORM dblink_exec(format('ALTER SYSTEM SET pgaudit.log TO %L;', array_to_string(events, ',')));
            PERFORM dblink_disconnect();
            PERFORM pg_reload_conf();
            IF persist_dblink_extension = FALSE
            THEN
                DROP EXTENSION IF EXISTS dblink;
            END IF;
            RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.set_pgaudit_session_logging(IN events text[]) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.set_pgaudit_session_logging(text[]) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.set_pgaudit_database_logging(text, text[])...';END$$;
CREATE FUNCTION public.set_pgaudit_database_logging(IN database text, IN events text[])
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
                persist_dblink_extension boolean;
                allowed_events TEXT [];
                input_valid boolean;
                pgaudit_ver_check boolean;
        BEGIN
            --misc_set is only available in pgAudit >= 1.4
            allowed_events := '{read,write,function,role,ddl,misc,misc_set,none}';
             --lower case the input for case insensitive comparison.
            SELECT array_agg(x.events) INTO events FROM (SELECT btrim(lower(unnest(events)))::TEXT AS events) AS x;
            SELECT events  <@ allowed_events INTO input_valid;
            IF not input_valid
            THEN
                RAISE EXCEPTION 'Invalid options provided: %, Allowed events: %.', events,allowed_events;
            END IF;
            persist_dblink_extension := create_dblink_extension();
            PERFORM dblink_connect(format('dbname=postgres'));
            PERFORM dblink_exec(format('ALTER DATABASE %I SET pgaudit.log TO %L;' ,database, array_to_string(events, ',')));
            PERFORM dblink_disconnect();
            PERFORM pg_reload_conf();
            IF persist_dblink_extension = FALSE
            THEN
                DROP EXTENSION IF EXISTS dblink;
            END IF;
            RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.set_pgaudit_database_logging(IN database text, IN events text[]) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.run_anon_init()...';END$$;
CREATE FUNCTION public.run_anon_init()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
BEGIN
  PERFORM anon.init();
  RETURN 'Anon init completed.';
END;
$_$;
ALTER FUNCTION public.run_anon_init() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.run_anon_init() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.refresh_subscription(text, text)...';END$$;
CREATE FUNCTION public.refresh_subscription(IN subscription_name text, IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %I REFRESH PUBLICATION', subscription_name));
                    PERFORM dblink_disconnect();

                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.refresh_subscription(IN subscription_name text, IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.refresh_subscription(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.pg_kill_connection(integer)...';END$$;
CREATE FUNCTION public.pg_kill_connection(IN integer)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
AS $_$select pg_terminate_backend($1);$_$;
ALTER FUNCTION public.pg_kill_connection(IN integer) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.pg_kill_connection(integer) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.list_subscriptions()...';END$$;
CREATE FUNCTION public.list_subscriptions()
RETURNS TABLE(subdbid oid, subname name, subowner oid, subenabled boolean, subconninfo text, subslotname name, subsynccommit text, subpublications text[])
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                BEGIN
                    RETURN QUERY SELECT s.subdbid,s.subname, s.subowner , s.subenabled ,s.subconninfo ,s.subslotname  ,s.subsynccommit ,s.subpublications from pg_subscription s;
                END
        $_$;
ALTER FUNCTION public.list_subscriptions() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.list_subscriptions() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.kill_all_connections()...';END$$;
CREATE FUNCTION public.kill_all_connections()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        BEGIN
                EXECUTE 'SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = current_database() AND pid <> pg_backend_pid()';
                RETURN 'ok';
        END
$_$;
ALTER FUNCTION public.kill_all_connections() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.kill_all_connections() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.k_anonymity()...';END$$;
CREATE FUNCTION public.k_anonymity()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
DECLARE
    role_name TEXT := 'admin';
BEGIN
    -- Check if the role 'admin' exists
    IF NOT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = role_name
    ) THEN
        RAISE EXCEPTION 'Role "%" does not exist.', role_name;
    END IF;

    -- Grant SELECT privilege on anon.pg_identifiers
    EXECUTE format(
        'GRANT SELECT ON anon.pg_identifiers TO %I;',
        role_name
    );

    RETURN format('Granted SELECT on anon.pg_identifiers to role "%s".', role_name);
END;
$_$;
ALTER FUNCTION public.k_anonymity() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.k_anonymity() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.grant_pgcron_privileges()...';END$$;
CREATE FUNCTION public.grant_pgcron_privileges()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
BEGIN

    EXECUTE  'GRANT EXECUTE ON FUNCTION cron.schedule_in_database TO admin';
    EXECUTE  'GRANT USAGE ON SCHEMA cron TO admin';
    RETURN  'Granted permission on pg_cron ';
END;
$_$;
ALTER FUNCTION public.grant_pgcron_privileges() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.grant_pgcron_privileges() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.grant_admin_option_to_roles(text[])...';END$$;
CREATE FUNCTION public.grant_admin_option_to_roles(VARIADIC role_list text[])
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
DECLARE
    role TEXT;
    pg_version INT;
BEGIN
    -- Get major PostgreSQL version
    SELECT current_setting('server_version_num')::INT / 10000 INTO pg_version;

    -- Check if version is 16 or higher
    IF pg_version < 16 THEN
        RAISE NOTICE 'Skipping: This function only applies to PostgreSQL 16 or higher. Current version: %', pg_version;
        RETURN;
    END IF;

    -- Loop through roles and grant ADMIN OPTION to admin (excluding certain roles)
    FOREACH role IN ARRAY role_list LOOP
        role := trim(role); -- Trim spaces from each role name

        -- Exclude specific roles dynamically
        IF role IN (
            'ibm', 
            'admin', 
            'repl', 
            'ibm-rewind', 
            'ibm-replication', 
            'ibm-cloud-base-user-ro', 
            'pg_monitor', 
            'pg_signal_backend'
        ) THEN
            RAISE NOTICE 'Skipping role: % (not allowed)', role;
        ELSE
            EXECUTE format('GRANT %I TO admin WITH ADMIN OPTION', role);
            RAISE NOTICE 'Granted ADMIN OPTION to admin for role: %', role;
            RAISE NOTICE 'Successfully processed roles.';
        END IF;
    END LOOP;
END;
$_$;
ALTER FUNCTION public.grant_admin_option_to_roles(VARIADIC role_list text[]) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.grant_admin_option_to_roles(text[]) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.enable_subscription(text, text)...';END$$;
CREATE FUNCTION public.enable_subscription(IN subscription_name text, IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %I ENABLE', subscription_name));
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.enable_subscription(IN subscription_name text, IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.enable_subscription(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.enable_masking_for_dump(text, text)...';END$$;
CREATE FUNCTION public.enable_masking_for_dump(IN role_name text, IN schema_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
BEGIN
  -- Input validation
  IF role_name IS NULL OR length(trim(role_name)) = 0 THEN
    RAISE EXCEPTION 'Role name must be provided';
  END IF;

  IF schema_name IS NULL OR length(trim(schema_name)) = 0 THEN
    RAISE EXCEPTION 'Schema name must be provided';
  END IF;

  -- Set the schema as TRUSTED for masking
  EXECUTE format(
    'SECURITY LABEL FOR anon ON SCHEMA %I IS ''TRUSTED'';',
    schema_name
  );

  -- Set dynamic masking for the specified role
  EXECUTE format(
    'ALTER ROLE %I SET anon.transparent_dynamic_masking TO TRUE;',
    role_name
  );

   RETURN format(
    'Dynamic masking for dump enabled for role "%s" and schema "%s".',
    role_name,
    schema_name
  );
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Error enabling dump masking: %', SQLERRM;    
END;
$_$;
ALTER FUNCTION public.enable_masking_for_dump(IN role_name text, IN schema_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.enable_masking_for_dump(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.enable_dynamic_masking(text)...';END$$;
CREATE FUNCTION public.enable_dynamic_masking(IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
BEGIN
    -- Validate input
    IF db_name IS NULL OR btrim(db_name) = '' THEN
        RAISE EXCEPTION 'Database name is required. Please provide a valid database name.';
    END IF;

    -- Check if the database exists
    IF NOT EXISTS (
        SELECT 1 FROM pg_database WHERE datname = db_name
    ) THEN
        RAISE EXCEPTION 'Database "%" does not exist.', db_name;
    END IF;

    -- Enable dynamic masking
    EXECUTE format('ALTER DATABASE %I SET anon.transparent_dynamic_masking TO true;', db_name);
    RETURN format('Dynamic masking enabled on database "%s".', db_name);
END;
$_$;
ALTER FUNCTION public.enable_dynamic_masking(IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.enable_dynamic_masking(text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.disable_subscription(text, text)...';END$$;
CREATE FUNCTION public.disable_subscription(IN subscription_name text, IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %I DISABLE', subscription_name));
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.disable_subscription(IN subscription_name text, IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.disable_subscription(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.delete_subscription(text, text)...';END$$;
CREATE FUNCTION public.delete_subscription(IN subscription_name text, IN db_name text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    PERFORM dblink_exec(format('Drop SUBSCRIPTION %I', subscription_name));
                    PERFORM dblink_disconnect();

                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.delete_subscription(IN subscription_name text, IN db_name text) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.delete_subscription(text, text) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.create_subscription(text, text, text, text, text, text, text, boolean, text, boolean)...';END$$;
CREATE FUNCTION public.create_subscription(IN subscription_name text, IN host_ip text, IN portnum text, IN password text, IN username text, IN db_name text, IN publisher_name text, IN copy_data boolean DEFAULT true, IN origin text DEFAULT 'ANY'::text, IN failover boolean DEFAULT true)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
                DECLARE
                     persist_dblink_extension boolean;
                     pg_ver int;
                BEGIN
                    IF origin is distinct from 'NONE' AND origin is distinct from 'ANY'
                    THEN
                        RETURN 'invalid argument value for origin';
                    END IF;
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%I', db_name));
                    -- Support origin and copy_data only in pg17 (earlier version don't support origin)
                    SELECT current_setting('server_version_num') INTO pg_ver;
                    IF pg_ver < 170000
                    THEN
                        -- PG < 17 (copy_data was supported earlier, but we care about origin)
                        PERFORM dblink_exec(format('CREATE SUBSCRIPTION %I CONNECTION %L PUBLICATION %I',
                            subscription_name,
                            format('host=%L port=%L password=%L user=%L dbname=%I sslmode=require', host_ip, portNum, password, username, db_name),
                            publisher_name));
                    ELSE
                        -- PG 17 and newer
                        PERFORM dblink_exec(format('CREATE SUBSCRIPTION %I CONNECTION %L PUBLICATION %I WITH ( copy_data = %s , failover = %s , origin = %s)',
                            subscription_name,
                            format('host=%L port=%L password=%L user=%L dbname=%I sslmode=require', host_ip, portNum, password, username, db_name),
                            publisher_name, copy_data::text, failover::text, origin));
                    END IF;
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
        $_$;
ALTER FUNCTION public.create_subscription(IN subscription_name text, IN host_ip text, IN portnum text, IN password text, IN username text, IN db_name text, IN publisher_name text, IN copy_data boolean, IN origin text, IN failover boolean) OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.create_subscription(text, text, text, text, text, text, text, boolean, text, boolean) TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.create_dblink_extension()...';END$$;
CREATE FUNCTION public.create_dblink_extension()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $_$
        DECLARE
                persist_dblink_extension boolean;
        BEGIN
            SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname='dblink')::boolean::boolean INTO persist_dblink_extension;
            IF persist_dblink_extension = FALSE
            THEN
                CREATE EXTENSION IF NOT EXISTS dblink;
            END IF;
            RETURN persist_dblink_extension;
        END
$_$;
ALTER FUNCTION public.create_dblink_extension() OWNER TO ibm;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Granting privilege(s) to admin...';END$$;
GRANT EXECUTE ON FUNCTION public.create_dblink_extension() TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.tipo_producto_id_seq...';END$$;
CREATE SEQUENCE public.tipo_producto_id_seq
AS integer
INCREMENT BY 1
MINVALUE 1
MAXVALUE 2147483647
START 1
CACHE 1
NO CYCLE;
ALTER SEQUENCE public.tipo_producto_id_seq OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.tipo_producto...';END$$;
CREATE TABLE public.tipo_producto (
    id integer NOT NULL DEFAULT nextval('public.tipo_producto_id_seq'::regclass),
    nombre character varying(100) NOT NULL,
    descripcion text
);
ALTER TABLE public.tipo_producto ADD CONSTRAINT tipo_producto_pkey PRIMARY KEY (id);
ALTER TABLE public.tipo_producto OWNER TO admin;
INSERT INTO public.tipo_producto(id, nombre, descripcion) OVERRIDING SYSTEM VALUE VALUES
(1, 'Electrónica', 'Dispositivos electrónicos como laptops, monitores, etc.'),
(2, 'Accesorios', 'Complementos como mouse, teclados, cables.'),
(3, 'Muebles', 'Mesas, sillas y soportes para oficina.')
ON CONFLICT (id) DO UPDATE SET nombre = EXCLUDED.nombre, descripcion = EXCLUDED.descripcion;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.tipo_producto_id_seq...';END$$;
ALTER SEQUENCE public.tipo_producto_id_seq OWNED BY public.tipo_producto.id;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.productos_id_seq...';END$$;
CREATE SEQUENCE public.productos_id_seq
AS integer
INCREMENT BY 1
MINVALUE 1
MAXVALUE 2147483647
START 1
CACHE 1
NO CYCLE;
ALTER SEQUENCE public.productos_id_seq OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.productos...';END$$;
CREATE TABLE public.productos (
    id integer NOT NULL DEFAULT nextval('public.productos_id_seq'::regclass),
    nombre character varying(100) NOT NULL,
    precio numeric(8,2) NOT NULL,
    stock integer DEFAULT 0,
    tipo_id integer NOT NULL
);
ALTER TABLE public.productos ADD CONSTRAINT productos_pkey PRIMARY KEY (id);
ALTER TABLE public.productos OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.productos_id_seq...';END$$;
ALTER SEQUENCE public.productos_id_seq OWNED BY public.productos.id;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.productos.productos_tipo_id_fkey...';END$$;
ALTER TABLE public.productos ADD CONSTRAINT productos_tipo_id_fkey FOREIGN KEY (tipo_id) REFERENCES public.tipo_producto (id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.ordenes_id_seq...';END$$;
CREATE SEQUENCE public.ordenes_id_seq
AS integer
INCREMENT BY 1
MINVALUE 1
MAXVALUE 2147483647
START 1
CACHE 1
NO CYCLE;
ALTER SEQUENCE public.ordenes_id_seq OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.ordenes...';END$$;
CREATE TABLE public.ordenes (
    id integer NOT NULL DEFAULT nextval('public.ordenes_id_seq'::regclass),
    cliente_id integer NOT NULL,
    fecha_orden date NOT NULL,
    total numeric(10,2) NOT NULL,
    estado character varying(20)
);
ALTER TABLE public.ordenes ADD CONSTRAINT ordenes_pkey PRIMARY KEY (id);
ALTER TABLE public.ordenes OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.ordenes_id_seq...';END$$;
ALTER SEQUENCE public.ordenes_id_seq OWNED BY public.ordenes.id;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.orden_detalle_id_seq...';END$$;
CREATE SEQUENCE public.orden_detalle_id_seq
AS integer
INCREMENT BY 1
MINVALUE 1
MAXVALUE 2147483647
START 1
CACHE 1
NO CYCLE;
ALTER SEQUENCE public.orden_detalle_id_seq OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.orden_detalle...';END$$;
CREATE TABLE public.orden_detalle (
    id integer NOT NULL DEFAULT nextval('public.orden_detalle_id_seq'::regclass),
    orden_id integer NOT NULL,
    producto_id integer NOT NULL,
    cantidad integer NOT NULL,
    precio_unitario numeric(8,2) NOT NULL
);
ALTER TABLE public.orden_detalle ADD CONSTRAINT orden_detalle_pkey PRIMARY KEY (id);
ALTER TABLE public.orden_detalle OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.orden_detalle_id_seq...';END$$;
ALTER SEQUENCE public.orden_detalle_id_seq OWNED BY public.orden_detalle.id;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.orden_detalle.orden_detalle_producto_id_fkey...';END$$;
ALTER TABLE public.orden_detalle ADD CONSTRAINT orden_detalle_producto_id_fkey FOREIGN KEY (producto_id) REFERENCES public.productos (id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.orden_detalle.orden_detalle_orden_id_fkey...';END$$;
ALTER TABLE public.orden_detalle ADD CONSTRAINT orden_detalle_orden_id_fkey FOREIGN KEY (orden_id) REFERENCES public.ordenes (id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.clientes_id_seq...';END$$;
CREATE SEQUENCE public.clientes_id_seq
AS integer
INCREMENT BY 1
MINVALUE 1
MAXVALUE 2147483647
START 1
CACHE 1
NO CYCLE;
ALTER SEQUENCE public.clientes_id_seq OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.clientes...';END$$;
CREATE TABLE public.clientes (
    id integer NOT NULL DEFAULT nextval('public.clientes_id_seq'::regclass),
    nombre character varying(100) NOT NULL,
    email character varying(150) NOT NULL,
    telefono character varying(20),
    fecha_registro date DEFAULT CURRENT_DATE,
    estado character varying(20)
);
ALTER TABLE public.clientes ADD CONSTRAINT clientes_pkey PRIMARY KEY (id);
ALTER TABLE public.clientes OWNER TO admin;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.clientes_id_seq...';END$$;
ALTER SEQUENCE public.clientes_id_seq OWNED BY public.clientes.id;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.ordenes.ordenes_cliente_id_fkey...';END$$;
ALTER TABLE public.ordenes ADD CONSTRAINT ordenes_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes (id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.tipo_producto_nombre_key...';END$$;
ALTER TABLE public.tipo_producto ADD CONSTRAINT tipo_producto_nombre_key UNIQUE (nombre);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_tipo_producto_nombre...';END$$;
CREATE INDEX idx_tipo_producto_nombre ON public.tipo_producto USING btree (nombre);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_productos_tipo...';END$$;
CREATE INDEX idx_productos_tipo ON public.productos USING btree (tipo_id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_productos_nombre_precio...';END$$;
CREATE INDEX idx_productos_nombre_precio ON public.productos USING btree (nombre, precio);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_ordenes_cliente_estado...';END$$;
CREATE INDEX idx_ordenes_cliente_estado ON public.ordenes USING btree (cliente_id, estado);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_detalle_orden...';END$$;
CREATE INDEX idx_detalle_orden ON public.orden_detalle USING btree (orden_id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.idx_clientes_estado...';END$$;
CREATE INDEX idx_clientes_estado ON public.clientes USING btree (estado);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating public.clientes_email_key...';END$$;
ALTER TABLE public.clientes ADD CONSTRAINT clientes_email_key UNIQUE (email);

SET check_function_bodies = true;
